import "../patterns/DwyerPatterns.spectra"

module Cross4
env CarsCount carsWaitingInVerticalRoad;
env CarsCount carsWaitingInHorizontalRoad;
env boolean verticalCarCrossing;
env boolean horizontalCarCrossing;
sys Color verticalLights;
sys Color horizontalLights;

type CarsCount = Int(0..5);
type Color = {GREEN, RED, OFF};

define
  accident:= verticalCarCrossing & horizontalCarCrossing;

define
  clearingIntersection:= verticalLights = RED & horizontalLights = RED;

predicate go(Color trafficLight)
{
  trafficLight = GREEN | trafficLight = OFF
}

predicate carStartsToCross(boolean carIsCrossing)
{
  !carIsCrossing & next(carIsCrossing)
}

predicate onDontGoCarsDontCross(Color light, boolean carCrossing)
{
  !go(light) -> ! carCrossing
}
predicate onGoLineShrinks(Color light, CarsCount thisLine, CarsCount otherLine)
{
  go(light) -> thisLine<otherLine | otherLine=0
}

asm freshStart:
 carsWaitingInVerticalRoad=0 & carsWaitingInHorizontalRoad=0 &
 !verticalCarCrossing & !horizontalCarCrossing;

asm verticalCarsWillNotStartCrossingUnlessTrafficLightSaysGo:
  G (carStartsToCross(verticalCarCrossing)->go(verticalLights));
asm horizontalCarsWillNotStartCrossingUnlessTrafficLightSaysGo:
  G  (carStartsToCross(horizontalCarCrossing) -> go(horizontalLights));

asm GF onDontGoCarsDontCross(verticalLights, verticalCarCrossing);
asm GF onDontGoCarsDontCross(horizontalLights, horizontalCarCrossing);

asm GF onGoLineShrinks(verticalLights, carsWaitingInVerticalRoad, carsWaitingInHorizontalRoad);
asm GF onGoLineShrinks(horizontalLights, carsWaitingInHorizontalRoad, carsWaitingInVerticalRoad);


asm ifVerticalDontGoLineWillNotShrink:
  G next(carsWaitingInHorizontalRoad) < carsWaitingInHorizontalRoad -> go(horizontalLights);
asm ifHorizontalDontGoLineWillNotShrink:
  G next(carsWaitingInVerticalRoad) < carsWaitingInVerticalRoad -> go(verticalLights);


gar preventDisasters:
  G !accident;

gar giveGoToVerticalIfLineIsLonger:
  pRespondsToS(carsWaitingInVerticalRoad>carsWaitingInHorizontalRoad,go(verticalLights));
gar giveGoToHorizontalIfLineIsLonger:
  pRespondsToS(carsWaitingInHorizontalRoad>carsWaitingInVerticalRoad,go(horizontalLights));


//gar G next(clearingIntersection) -> verticalCarCrossing | horizontalCarCrossing;
gar G (next(blinksMain =1) -> carsWaitingInHorizontalRoad> carsWaitingInVerticalRoad);
gar G (next(blinksSide =1) -> carsWaitingInVerticalRoad> carsWaitingInHorizontalRoad);

predicate blinkBeforeSwitchingToRed(Color light)
{
  light = OFF & next(light = GREEN) | light=GREEN & next(light=OFF)
}


counter blinksMain(0..3) {
    // initially no blinks
    blinksMain=0;
    // blinking is turning light on when it was off
    inc: blinkBeforeSwitchingToRed(verticalLights);
    // reset counter when not at station
    reset: go(horizontalLights);
    // blink exactly 3 times
    overflow: false;
}
gar pBecomesTrue_betweenQandR(blinksMain=3,verticalLights = GREEN,verticalLights = RED);

gar G next(verticalLights = OFF) -> verticalLights=GREEN;
gar G blinksMain > 0 & blinksMain <3 -> blinkBeforeSwitchingToRed(verticalLights);



counter blinksSide(0..3) {
    // initially no blinks
    blinksSide=0;
    // blinking is turning light on when it was off
    inc: blinkBeforeSwitchingToRed(horizontalLights);
    // reset counter when not at station
    reset: go(verticalLights);
    // blink exactly 3 times
    overflow: false;
}
gar pBecomesTrue_betweenQandR(blinksSide=3,horizontalLights = GREEN,horizontalLights = RED);

gar G next(horizontalLights = OFF) -> horizontalLights= GREEN;
gar G blinksSide > 0 & blinksSide <3 -> blinkBeforeSwitchingToRed(horizontalLights);

gar G !(verticalLights = OFF & next(verticalLights=OFF) );
gar G !(horizontalLights = OFF & next(horizontalLights=OFF) );

gar G next(!clearingIntersection) & clearingIntersection -> !verticalCarCrossing & !horizontalCarCrossing;
//gar G PREV(draining) & goMain=GREEN -> carMain>=carSide;


